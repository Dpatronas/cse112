#!/usr/bin/perl
# $Id: pmake,v 1.37 2021-02-24 13:17:46-08 - - $

# Despina Patronas (dpatrona)
# Adam Barsness    (abarsnes)

$0 =~ s|.*/||;
use Getopt::Std;
use Data::Dumper;
use strict;
use warnings;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
sub dump_hash ($\%) {
   my ($label, $hashptr) = @_;
   print STDERR "%$label: ", Data::Dumper->Dump ([$hashptr]);
}

my $STATUS = 0;
END { exit $STATUS; }
$SIG{'__WARN__'} = sub { print STDERR @_; $STATUS = 1; };
$SIG{'__DIE__'} = sub { print STDERR @_; $STATUS = 1; exit; };

# sigtoperl: x86_64 Linux unix1.lt.ucsc.edu
# sigtoperl: Sun Nov 22 17:33:55 2020
my %strsignal = (
    0 => "Unknown signal 0",
    1 => "Hangup",
    2 => "Interrupt",
    3 => "Quit",
    4 => "Illegal instruction",
    5 => "Trace/breakpoint trap",
    6 => "Aborted",
    7 => "Bus error",
    8 => "Floating point exception",
    9 => "Killed",
   10 => "User defined signal 1",
   11 => "Segmentation fault",
   12 => "User defined signal 2",
   13 => "Broken pipe",
   14 => "Alarm clock",
   15 => "Terminated",
   16 => "Stack fault",
   17 => "Child exited",
   18 => "Continued",
   19 => "Stopped (signal)",
   20 => "Stopped",
   21 => "Stopped (tty input)",
   22 => "Stopped (tty output)",
   23 => "Urgent I/O condition",
   24 => "CPU time limit exceeded",
   25 => "File size limit exceeded",
   26 => "Virtual timer expired",
   27 => "Profiling timer expired",
   28 => "Window changed",
   29 => "I/O possible",
   30 => "Power failure",
   31 => "Bad system call",
);

### Hashes ###
my %OPTIONS; # options defined
my %GRAPH;   # dependencies
my %MACROS;  # defined macros
my %VISITED; # Hash for visited goals. Set vist goal: ${VISITED} = 1

# When a command is detected, run_command to execute cmd
# Returns 0 or undef when everything runs fine

sub run_command (@) {   
   my (@command) = @_;
   
   # Check for the @
   my $remove_at = substr $command[0], 7;
   my $at_sym = substr $command[0], 0,1;

   # Found at run_command without @ echo
   if ($at_sym eq "@") {
      sub run_command(@); 
      run_command($remove_at);
   }
   # Run command normally with print
   else {
      #@command =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||@command/ge;
      #@command =~ s/\$\$/\$/;            
      print "@command\n";
      my $status = eval {no warnings; system @command};

      # return undef means exit(0) success exit
      return undef unless $status;
      return "$!" if $status == -1;
      my $signal = $status & 0x7F;
      my $core = $status & 0x80;
      my $exit = ($status >> 8) & 0xFF;
      return "Error $exit" unless $signal || $core;
      return ($strsignal{$signal} || "Invalid Signal Number $signal")
           . ($core ? " (core dumped)" : "");
   }
}

my $MAKECMDGOALS;
my $Makefile = "Makefile";

sub usage() { die "Usage: $0 [-mgd] [target]\n" }
sub stop($) { die "$Makefile:@_. Stop.\n" }

sub scan_cmdline() {
   getopts "dgm", \%OPTIONS;
   usage unless @ARGV <= 1;
   $MAKECMDGOALS = $ARGV[0] if @ARGV == 1;
}

# Debugging purposes
sub dump_graph() {
   print STDERR "%MACROS:\n";
   for my $macro (sort keys %MACROS) {
      printf STDERR "%7d [%s] = [%s]\n",
             $MACROS{$macro}{LINE}, $macro, $MACROS{$macro}{VALUE};
   }
   print STDERR "MAKECMDGOALS = [$MAKECMDGOALS]\n";
   print STDERR "%GRAPH:\n";
   for my $target (sort keys %GRAPH) {
      my $prereqs = $GRAPH{$target}{PREREQS};
      printf STDERR "%7d [%s] :", $GRAPH{$target}{LINE}, $target;
      print STDERR " [$_]" for @$prereqs;
      print STDERR "\n";
      for my $cmd (@{$GRAPH{$target}{COMMANDS}}) {
         printf STDERR "%7d.\t[%s]\n", $cmd->{LINE}, $cmd->{CMD};;
      }
   }
}

sub load_Makefile() {
   open my $mkfile, "<$Makefile" or die "$0: $Makefile: $!";
   my $target;
   while (defined (my $line = <$mkfile>)) {
      next if $line =~ m/^\s*(#|$)/;
      # Defining a macros
      if (!$target && $line =~ m/^\s*(\S+)\s*=\s*(.*?)\s*$/) {
         $MACROS{$1} = {LINE=> $., VALUE=> $2};
      }elsif ($line =~ m/^(\S+)\s*:\s*(.*)/) {
         #$line =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$line/ge; # Macro replace
         my $tempprereq = $2;
         $target = $1; 						# Keep default if not macro
         $target =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$target/ge;# Macro replace
         #$target =~ s/\$\$/\$/; 				# Regex formatting
         #my $tempprereq = $2;
         #print "Temp prereq: $tempprereq\n";
         $tempprereq =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$tempprereq/ge;  # Macro replace
         ##$tempprereq =~ s/\$\$/\$/;                             # Regex formatting        
         $GRAPH{$target}{PREREQS} = [split ' ', $tempprereq];
         $GRAPH{$target}{LINE} = $.;
         $MAKECMDGOALS = $target unless $MAKECMDGOALS;
      }elsif ($line =~ m/^\t(.*)/) {
         if (defined $target) {
            my $tempcmd = $1;
            $tempcmd =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$tempcmd/ge;
            push @{$GRAPH{$target}{COMMANDS}},
                 {LINE=> $., CMD=> $tempcmd};
         }else {
            stop "$.: Command before first target";
         }
      }else {
         stop "$.: Missing separator";
      }
   }
   close $mkfile;
}

sub get_time($) {
   my ($filename) = @_;
   my @stat = stat $filename;
   return @stat ? $stat[9] : undef;
}


sub mac_replace(){
   for my $target (sort keys %GRAPH) {
      my $prereq = $GRAPH{$target}{PREREQS};
      my $commds = $GRAPH{$target}{COMMANDS};  # ref commands array
      #print "CMD before: $commds\n";			# check cmd

      foreach my $pre (@$prereq){
         #print "Before: $pre\n";
         $pre =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$pre/ge;
         $pre =~ s/\$\$/\$/;
         #print "After: $pre\n";
      }
      foreach my $cmdhash (@$commds){
         #print "CMDHASH Before: $cmdhash\n";
        
         #my $cmd = $cmdhash{1};
         #print "CMD Before: $cmdhash->{CMD}";   

         #foreach my $subcmd ($cmdhash{CMD}){
            #print "Before: $subcmd\n";
            #$subcmd =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$subcmd/ge;
            ##$subcmd =~ s/\$\$/\$/;
            #print "After: $subcmd\n";
            #print "String Before: $cmdstring\n";
            #$cmdstring = join(" ", $cmdstring, $subcmd);
            #print "String After: $cmdstring\n";
         #}
         #$cmd = %cmdhash;
      }
      
      #$GRAPH{$target}{PREREQS};
      #print "Before: $target\n";
      #$target =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$target/ge;
      #$target =~ s/\$\$/\$/;
      #print "After: $target\n";
      #$GRAPH{$target}{PREREQS} = [split ' ', $prereq];
   }
}

sub make_goal($) {
   my ($goal) = @_;
   my $prereq = $GRAPH{$goal}{PREREQS};  # ref prereq array
   my $commds = $GRAPH{$goal}{COMMANDS}; # ref commands array

   #print "GOAL TEST: $goal\n";
   
   foreach my $pre (@$prereq){
      #print "PRE TEST: $pre\n";
      #$pre =~ s/\${(.*?)}/$MACROS{$1}{PRE}||$pre/ge;
      #$pre =~ s/\$\$/\$/;
      #print "After: $pre\n";
   }
   foreach my $cmd (@$commds){
      #print "CMD TEST: $cmd\n";
      #$cmd =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||""/ge; 
      #$cmd =~ s/\$\$/\$/;
      #print "After: $cmd\n";
   }

   sub make_goal($);          # fwd declaration fnx

   # Check if goal is !target
   if (!defined $goal) {
      
      # Check if goal is a file 
      my $findfile = system("find $goal");
      if (-e $findfile) {
         print "found file: $findfile\n";
         return get_time($findfile);      # Return modtime
      }
      else {
         print "file not found";
      } 
   }

   # For each prereq (check if prereq exists or not)
   if (defined $prereq->[0]) {         # deref check indx0 prereq arr
      #foreach my $pre (@$prereq){
          #print "Before: $pre\n";
          #$pre =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||""/ge;
          #$pre =~ s/$</$prereq/;
          #$pre =~ s/\$\$/\$/;
          #print "After: $pre\n";
      #}


      # Prereq exists
      foreach my $pre (@$prereq) {     # iterate prereq arr indxs
         make_goal($pre);              # Recurs make on indexes
      }
      # Check command on prereq
      foreach my $cmd (@$commds) {
         my %cmdhash = %$cmd;          # Make a hash of cmds
         # print "cmd p : $cmdhash{CMD}\n";
         #$cmd =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$cmd/ge;
         #$cmd =~ s/\$\$/\$/;
         run_command($cmdhash{CMD});   # run cmd
      }
   }
   # Check Commands (no prereq found)
   else {
      #print "no prereq\n";
      foreach my $cmd (@$commds) {  
         my %cmdhash = %{$cmd};        # make hash of cmds
         #$cmdhash{CMD} =~ s/\${(.*?)}/$MACROS{$1}{VALUE}||$cmdhash{CMD}/ge;
         #$cmdhash{CMD} =~ s/\$\$/\$/;
         # print "cmd !p: $hash{CMD}";
         run_command($cmdhash{CMD});   # run cmd
      }
   }       
}

scan_cmdline;
load_Makefile;

dump_graph if $OPTIONS{'d'};

mac_replace;
dump_hash ("MACROS", %MACROS) if $OPTIONS{'m'};
dump_hash ("GRAPH", %GRAPH) if $OPTIONS{'g'};
dump_graph if $OPTIONS{'d'};

#mac_replace;
make_goal ($MAKECMDGOALS);

